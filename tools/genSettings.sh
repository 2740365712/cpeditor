#!/bin/bash

SETTING="setting.json";

exec 3>"include/Core/SettingsHelper.hpp";
exec 4>"include/Core/SettingsInfo.hpp";

license="/*
 * Copyright (C) 2019-2020 Ashar Khan <ashar786khan@gmail.com>
 *
 * This file is part of CP Editor.
 *
 * CP Editor is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * I will not be responsible if CP Editor behaves in unexpected way and
 * causes your ratings to go down and or lose any important contest.
 *
 * Believe Software is \"Software\" and it isn't immune to bugs.
 *
 */

/*
 * This file is auto generated by tools/genSettings.sh
 */";

echo "$license

#ifndef SETTINGSHELPER_HPP
#define SETTINGSHELPER_HPP

#include \"Core/Settings.hpp\"

namespace SettingsHelper
{" >&3;
types=($(jq '.[].type' "$SETTING"));
count=${#types[@]};
for ((i=0;i<count;++i)); do
    name="$(jq -r ".[$i].name" "$SETTING")";
    namestr="$(jq ".[$i].name" "$SETTING")";
    type="$(jq -r ".[$i].type" "$SETTING")";
    key="$(echo "$name" | tr -d ' /' | tr '+' 'p')";
    echo "    inline void set$key($type value) { SettingsManager::set($namestr, value); }" >&3;
    if [ "$type" == "bool" ]; then
        echo "    inline $type is$key() { return SettingsManager::get($namestr).value<$type>(); }" >&3;
    else
        echo "    inline $type get$key() { return SettingsManager::get($namestr).value<$type>(); }" >&3;
    fi
done
echo -n "}

#endif // SETTINGSHELPER_HPP" >&3;

echo "$license

#ifndef SETTINGSINFO_HPP
#define SETTINGSINFO_HPP

#include <QString>
#include <QFont>
#include <QRect>
#include <QByteArray>
#include <QVariant>

struct SettingInfo
{
    QString name, desc, type, ui;
    QStringList old;
    QVariant def;
    QVariant param;

    QString key() const
    {
        return name.toLower().replace('+', 'p').replace(' ', '_');
    }
};

const SettingInfo settingInfo[] =
{" >&4;
for ((i=0;i<count;++i)); do
    name="$(jq ".[$i].name" "$SETTING")";
    if [ "$(jq ".[$i].desc" "$SETTING")" != "null" ]; then
        desc="$(jq ".[$i].desc" "$SETTING")";
    else
        desc="${name/\// }";
    fi
    type="$(jq -r ".[$i].type" "$SETTING")";
    if [ "$(jq ".[$i].ui" "$SETTING")" != "null" ]; then
        ui="$(jq -r ".[$i].ui" "$SETTING")";
    else
        ui='';
    fi
    echo -n "    {$name, $desc, \"$type\", \"$ui\", {" >&4;
    if [ "$(jq ".[$i].old" "$SETTING")" != "null" ]; then
        olds=($(jq ".[$i].old[]" "$SETTING"));
        ocnt=${#olds[@]};
        echo -n "$(jq ".[$i].old[0]" "$SETTING")" >&4;
        for ((j=1;j<ocnt;++j)); do
            echo -n ", $(jq ".[$i].old[$j]" "$SETTING")" >&4;
        done
    fi
    echo -n "}, " >&4;
    if [ "$(jq ".[$i].default" "$SETTING")" != "null" ]; then
        if [ "$type" == "QString" ]; then
            echo -n "$(jq ".[$i].default" "$SETTING")" >&4;
        else
            echo -n "$(jq -r ".[$i].default" "$SETTING")" >&4;
        fi
    else
        case "$type" in
            QString)
                echo -n '""' >&4;
                ;;
            int)
                echo -n '0' >&4;
                ;;
            bool)
                echo -n 'false' >&4;
                ;;
            QRect|QByteArray)
                echo -n "$type()" >&4;
                ;;
        esac
    fi
    if [ "$(jq ".[$i].param" "$SETTING")" != "null" ]; then
        echo -n ", $(jq -r ".[$i].param" "$SETTING")" >&4;
    fi
    echo "}," >&4;
done
echo -n "};

inline SettingInfo findSetting(const QString &name)
{
    for (const SettingInfo &si: settingInfo)
        if (si.name == name)
            return si;
    return SettingInfo();
}

#endif // SETTINGSINFO_HPP" >&4;

exec 3<&-;
exec 4<&-;